import { NextRequest } from 'next/server'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function POST(request: NextRequest) {
  try {
    const { mission } = await request.json()

    if (!mission) {
      return new Response(
        JSON.stringify({ error: 'Mission is required' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      )
    }

    const encoder = new TextEncoder()
    const stream = new ReadableStream({
      async start(controller) {
        try {
          // Simulate the CrewAI execution for local development
          const events = [
            { type: 'log', agent: 'System', message: 'ðŸš€ Initializing NexusAgents...' },
            { type: 'log', agent: 'System', message: 'âœ… LLM initialized' },
            { type: 'log', agent: 'System', message: 'âœ… Search tool initialized' },
            { type: 'log', agent: 'System', message: 'âœ… Researcher Agent initialized' },
            { type: 'log', agent: 'System', message: 'âœ… Analyst Agent initialized' },
            { type: 'log', agent: 'System', message: 'ðŸ“‹ Tasks configured' },
            { type: 'log', agent: 'Manager', message: `ðŸŽ¯ Mission started: ${mission.substring(0, 100)}...` },
            { type: 'log', agent: 'Researcher', message: 'ðŸ” Searching for information...' },
          ]

          // Send initial events
          for (const event of events) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(event)}\n\n`)
            )
            await sleep(500)
          }

          // Simulate research phase
          await sleep(2000)
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ 
              type: 'log', 
              agent: 'Researcher', 
              message: 'ðŸ“Š Found relevant information sources...' 
            })}\n\n`)
          )

          await sleep(1000)
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ 
              type: 'log', 
              agent: 'Analyst', 
              message: 'ðŸ“Š Analyzing and synthesizing results...' 
            })}\n\n`)
          )

          // Simulate artifact generation
          const mockReport = `# Mission Report: ${mission}

## Executive Summary
This is a simulated response for local development. In production, this would be generated by the CrewAI agents using real AI models and web search capabilities.

## Key Findings
- **Finding 1**: Relevant information about the mission topic
- **Finding 2**: Additional insights and data points  
- **Finding 3**: Technical considerations and best practices

## Code Example
Here's a sample implementation:

\`\`\`javascript
// Example AI agent implementation
class AIAgent {
  constructor(name, role) {
    this.name = name;
    this.role = role;
    this.status = 'ready';
  }

  async executeTask(task) {
    console.log(\`\${this.name} executing: \${task}\`);
    
    // Simulate AI processing
    const result = await this.processWithAI(task);
    
    return {
      agent: this.name,
      task: task,
      result: result,
      timestamp: new Date()
    };
  }

  async processWithAI(input) {
    // AI processing logic here
    return \`Processed: \${input}\`;
  }
}

// Usage
const researcher = new AIAgent('Researcher', 'data-gathering');
const analyst = new AIAgent('Analyst', 'data-analysis');
\`\`\`

## Python Implementation
\`\`\`python
from crewai import Agent, Task, Crew

# Define AI agents
researcher = Agent(
    role='Research Specialist',
    goal='Gather comprehensive information',
    backstory='Expert in information retrieval',
    tools=[search_tool]
)

analyst = Agent(
    role='Data Analyst', 
    goal='Analyze and synthesize findings',
    backstory='Senior analyst with deep expertise',
    tools=[analysis_tool]
)

# Create tasks
research_task = Task(
    description="Research the given topic thoroughly",
    agent=researcher
)

analysis_task = Task(
    description="Analyze research findings",
    agent=analyst
)

# Execute crew
crew = Crew(
    agents=[researcher, analyst],
    tasks=[research_task, analysis_task]
)

result = crew.kickoff()
\`\`\`

## Recommendations
1. **Immediate Actions**: 
   - Implement the core agent framework
   - Set up proper error handling
   - Configure API integrations

2. **Medium-term Goals**: 
   - Add advanced reasoning capabilities
   - Implement multi-agent coordination
   - Build comprehensive testing suite

3. **Long-term Strategy**: 
   - Scale to handle complex workflows
   - Add machine learning optimization
   - Develop custom agent personalities

## Configuration Example
\`\`\`yaml
# agents.yaml
agents:
  researcher:
    role: "Research Specialist"
    tools: ["web_search", "document_reader"]
    max_iterations: 5
    
  analyst:
    role: "Data Analyst"
    tools: ["data_processor", "chart_generator"]
    max_iterations: 3
    
  coordinator:
    role: "Mission Coordinator"
    tools: ["task_manager", "report_generator"]
    max_iterations: 2
\`\`\`

## API Response Example
\`\`\`json
{
  "status": "success",
  "data": {
    "mission_id": "12345",
    "agents": [
      {
        "name": "researcher",
        "status": "active",
        "progress": 85
      },
      {
        "name": "analyst", 
        "status": "completed",
        "progress": 100
      }
    ],
    "results": {
      "findings": ["Finding 1", "Finding 2"],
      "recommendations": ["Rec 1", "Rec 2"]
    }
  }
}
\`\`\`

## Next Steps
- [ ] Implement the recommended actions
- [ ] Monitor progress and adjust strategy as needed
- [ ] Continue research and development efforts
- [ ] Deploy to production environment

> **Important Note**: This is a development simulation. Deploy to Vercel for full CrewAI functionality with real AI models and web search.

---
**Generated by NexusAgents** | *Powered by CrewAI & Groq*`

          // Stream the report in logical chunks (by lines/paragraphs)
          const lines = mockReport.split('\n')
          let currentChunk = ''
          
          for (const line of lines) {
            // Add line to current chunk
            currentChunk += line + '\n'
            
            // Send chunk when it reaches a reasonable size or at paragraph breaks
            if (currentChunk.length > 200 || line.trim() === '' || line.startsWith('#') || line.startsWith('```')) {
              if (currentChunk.trim()) {
                controller.enqueue(
                  encoder.encode(`data: ${JSON.stringify({ type: 'artifact', content: currentChunk })}\n\n`)
                )
                await sleep(150)
              }
              currentChunk = ''
            }
          }
          
          // Send any remaining content
          if (currentChunk.trim()) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ type: 'artifact', content: currentChunk })}\n\n`)
            )
          }

          await sleep(500)
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ 
              type: 'log', 
              agent: 'Manager', 
              message: 'âœ¨ Mission completed successfully!' 
            })}\n\n`)
          )

          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ type: 'complete' })}\n\n`)
          )

          controller.close()
        } catch (error) {
          controller.enqueue(
            encoder.encode(
              `data: ${JSON.stringify({ type: 'error', message: String(error) })}\n\n`
            )
          )
          controller.close()
        }
      },
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
      },
    })
  } catch (error) {
    return new Response(
      JSON.stringify({ error: String(error) }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
}

export async function OPTIONS() {
  return new Response(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  })
}

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms))
}